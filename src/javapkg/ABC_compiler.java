/* Generated By:JJTree&JavaCC: Do not edit this line. ABC_compiler.java */
    package javapkg;
  import java.util.ArrayList;
  import java.util.HashMap;
  import java.io.*;
  import com.google.gson.Gson;
    import com.google.gson.GsonBuilder;

        public class ABC_compiler/*@bgen(jjtree)*/implements ABC_compilerTreeConstants, ABC_compilerConstants {/*@bgen(jjtree)*/
  protected JJTABC_compilerState jjtree = new JJTABC_compilerState();
    public HashMap<String, ArrayList<Command> > funcMap =
               new HashMap<String, ArrayList<Command> >();
        public ArrayList<Sentence> sentences=new ArrayList<Sentence>();
        public ArrayList<Variable> variables=new ArrayList<Variable>();
        public int scope = 0;
        public static ABC_compiler compiler;

        public static void main(String[] args)
        throws ParseException, TokenMgrError,
        NumberFormatException, FileNotFoundException, IOException {
                compiler = new ABC_compiler(
                                new FileInputStream("res/input.txt"));
                compiler.init();
                compiler.parse();
        }

        public void init() {
            funcMap.clear();
            sentences.clear();
            variables.clear();
            scope = 0;
        }
        public void parse() throws IOException {
    try{
            SimpleNode node = Procedure();

            sendTree(node);

            // node.dump("");

//                System.out.println("-----sentences-----");
//                System.out.println("size = " + sentences.size());
//                for (Sentence sentence : sentences) {
//                    System.out.println("[Sentence]");
//                    sentence.display();
//                }
//                System.out.println();
//                System.out.println("variables:");
//                for (Variable variable : variables)
//                  System.out.println(variable.getName() + " "
//                    + variable.getType() + " " + variable.getVal());
//                System.out.println();

          }catch(ParseException e)
          {
            sendErrorMsg(new ErrorType(2,e.getMessage()));
          }
        ErrorType err = Generator.generate_code(this, sentences);
        if (err.errortype == 2) {
            onGenFailure(err);
        }
        }

        public void onGenSuccess(ArrayList<String> code) throws IOException {
            System.out.println("Generate Success");
            System.out.println(code);
            sendTargetCode(code);
            Simulator.simulate(this, code);
        }

        public void onGenFailure(ErrorType err) throws IOException {
            System.out.println("Generate Failure");
            err.display();
            sendErrorMsg(err);
        }

        public void sendErrorMsg(ErrorType err) throws IOException {
            Message msg = new Message(err);
            WebSocket.sendMessage(this, new Gson().toJson(msg));
        }

        public void sendTargetCode(ArrayList<String> code) throws IOException {
          Message msg = new Message(code);
          WebSocket.sendMessage(this, new Gson().toJson(msg));
        }

        public void sendTree(SimpleNode tree) throws IOException {
                Message msg = new Message(tree);
                        Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
                WebSocket.sendMessage(this, gson.toJson(msg));
        }

        public void sendMsg(Operation oper) throws IOException {
            Message msg = new Message(oper);
            WebSocket.sendMessage(this, new Gson().toJson(msg));
        }

        public void finish() throws IOException {
            WebSocket.sendMessage(this, "finish");
        }

  final public SimpleNode Procedure() throws ParseException {
                             /*@bgen(jjtree) Root */
  ASTRoot jjtn000 = new ASTRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEFINE:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        Define();
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FUNC:
        case INT:
        case DOUBLE:
        case IF:
        case WHILE:
        case CAR:
        case TEAM:
        case ID:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case DOUBLE:
        case IF:
        case WHILE:
        case CAR:
        case TEAM:
        case ID:
          Statement(ABC_Constant.NORMAL_STMT);
          break;
        case FUNC:
          FunctionDef();
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      MainFunction();
      jj_consume_token(0);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Define() throws ParseException {
 /*@bgen(jjtree) Define */
    ASTDefine jjtn000 = new ASTDefine(JJTDEFINE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFINE);
      t = jj_consume_token(ID);
      IntLiteralValue();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        Variable newVar = new Variable(t.image, ABC_Constant.INT, scope);
        if(variables.size()!=0)
        {
          if (funcMap.containsKey(t.toString()))
            {if (true) throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a function.");}
          for(Variable v:variables)
          {
            if(t.image.equals(v.getName()) && v.getScope() <= scope)
              {if (true) throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a variable.");}
          }
        }
        ASTIntLiteralValue child = (ASTIntLiteralValue)jjtn000.jjtGetChild(0);
        newVar.setVal(String.valueOf(child.getVal()));
        variables.add(newVar);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void MainFunction() throws ParseException {
                     /*@bgen(jjtree) MainFunction */
  ASTMainFunction jjtn000 = new ASTMainFunction(JJTMAINFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(VOID);
      jj_consume_token(MAIN);
      jj_consume_token(LPAR);
      jj_consume_token(RPAR);
      Block();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Block() throws ParseException {
 /*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);scope++;
    try {
      jj_consume_token(LBRACE);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case DOUBLE:
        case IF:
        case WHILE:
        case CAR:
        case TEAM:
        case ID:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_3;
        }
        Statement(ABC_Constant.NORMAL_STMT);
      }
      jj_consume_token(RBRACE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Util.closeScope(this); scope--;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void FunctionDef() throws ParseException {
 /*@bgen(jjtree) FunctionDef */
  ASTFunctionDef jjtn000 = new ASTFunctionDef(JJTFUNCTIONDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String funcName = "";
    try {
      try {
        jj_consume_token(FUNC);
        funcName = jj_consume_token(ID).image;
        jj_consume_token(LPAR);
        jj_consume_token(RPAR);
        jj_consume_token(LBRACE);
             scope++;
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FORWARD:
          case BACK:
          case ROTATE:
          case MOVE_TO:
          case BRAKE:
          case WAIT:
          case OBSTACLE:
          case X:
          case Y:
          case DIR:
          case SENSOR:
          case REPORT:
          case TEAM_ADD:
          case TEAM_REMOVE:
          case ID:
            ;
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_4;
          }
          Action();
          jj_consume_token(SEMI_COL);
        }
        jj_consume_token(RBRACE);
      } catch (Exception e) {
      System.out.println(e.toString());
      sendErrorMsg(new ErrorType(2,e.getMessage()));
      // Token t;
      // do {
      //   t = getNextToken();
      // } while (t.kind != RBRACE);

      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    try {
    boolean funcHasDefinedByVal=false;
    for(Variable v:variables)
    {
      if(funcName.equals(v.getName()) && v.getScope() <= scope)
        funcHasDefinedByVal=true;
    }
    if (funcMap.containsKey(funcName))
      {if (true) throw new ParseException("Error: function '"+funcName+"' the name has been used for a function.");}
    else if (funcHasDefinedByVal)
      {if (true) throw new ParseException("Error: function '"+funcName+"' the name has been used for a variable.");}
    else{
      ArrayList<Command> funcCommands = new ArrayList<Command>();
      for (int i = 0; i < jjtn000.jjtGetNumChildren(); i++) {
        ASTAction action = (ASTAction) jjtn000.jjtGetChild(i);
        funcCommands.add(
          new Command(0, 0, action.getName(),
            action.getFuncName(), action.getParamList()));
      }
      funcMap.put(funcName, funcCommands);
    }
    Util.closeScope(this);
     scope--;
     }catch (Exception e) {
           System.out.println(e.toString());
           sendErrorMsg(new ErrorType(2,e.getMessage()));
           // Token t;
           // do {
           //   t = getNextToken();
           // } while (t.kind != RBRACE);
         }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void IfConditionStatement(int type) throws ParseException {
 /*@bgen(jjtree) IfConditionStatement */
    ASTIfConditionStatement jjtn000 = new ASTIfConditionStatement(JJTIFCONDITIONSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Sentence execStmt;
    try {
      jj_consume_token(IF);
      jj_consume_token(LPAR);
      Condition(ABC_Constant.IF_STMT);
      jj_consume_token(RPAR);
      jj_consume_token(LBRACE);
              scope++;
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case DOUBLE:
        case IF:
        case WHILE:
        case CAR:
        case TEAM:
        case ID:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_5;
        }
        Statement(ABC_Constant.IF_STMT);
      }
      jj_consume_token(RBRACE);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        jjtn000.setCondition((ASTCondition)jjtn000.jjtGetChild(0));
        for (int i = 1; i < jjtn000.jjtGetNumChildren(); i++) {
            ASTStatement child = (ASTStatement) jjtn000.jjtGetChild(i);
            System.out.println("stmt: " + new Gson().toJson(child.getCommand()));
            if (child.getCommand().getFunctionName() == ABC_Constant.FUNCTION)
                  Util.addExecStmt(this, jjtn000,
                    child.getCommand().getMyFuncName(),
                    child.getCommand().getObjectName(),
                    child.getCommand().getObjectID());
                else
                  jjtn000.addExecStmt(this, child);
        }
//        jjtThis.toSentence().display();
//        jjtThis.outputIfStatement();
        sentences.add(jjtn000.toSentence());
        Util.closeScope(this);
        scope--;
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void WhileConditionStatement(int type) throws ParseException {
 /*@bgen(jjtree) WhileConditionStatement */
    ASTWhileConditionStatement jjtn000 = new ASTWhileConditionStatement(JJTWHILECONDITIONSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Sentence execStmt;
    try {
      jj_consume_token(WHILE);
      jj_consume_token(LPAR);
      Condition(ABC_Constant.WHILE_STMT);
      jj_consume_token(RPAR);
      jj_consume_token(LBRACE);
              scope++;
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case DOUBLE:
        case IF:
        case WHILE:
        case CAR:
        case TEAM:
        case ID:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_6;
        }
        Statement(ABC_Constant.WHILE_STMT);
      }
      jj_consume_token(RBRACE);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        jjtn000.setCondition((ASTCondition)jjtn000.jjtGetChild(0));
        for (int i = 1; i < jjtn000.jjtGetNumChildren(); i++) {
            ASTStatement child = (ASTStatement) jjtn000.jjtGetChild(i);
            if (child.getCommand().getFunctionName() == ABC_Constant.FUNCTION)
                  Util.addExecStmt(this, jjtn000,
                    child.getCommand().getMyFuncName(),
                    child.getCommand().getObjectName(),
                    child.getCommand().getObjectID());
                else
                  jjtn000.addExecStmt(this, child);
        }
//        jjtThis.outputWhileStatement();
        sentences.add(jjtn000.toSentence());
        Util.closeScope(this);
        scope--;
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void Condition(int type) throws ParseException {
 /*@bgen(jjtree) Condition */
  ASTCondition jjtn000 = new ASTCondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      BoolVariable(type);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        jj_consume_token(LT);
            jjtn000.setOperator(ABC_Constant.LESS_THAN);
        break;
      case LE:
        jj_consume_token(LE);
            jjtn000.setOperator(ABC_Constant.LESS_EQUAL);
        break;
      case MT:
        jj_consume_token(MT);
            jjtn000.setOperator(ABC_Constant.MORE_THAN);
        break;
      case ME:
        jj_consume_token(ME);
            jjtn000.setOperator(ABC_Constant.MORE_EQUAL);
        break;
      case EQ:
        jj_consume_token(EQ);
            jjtn000.setOperator(ABC_Constant.EQUAL);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      BoolVariable(type);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.setLeft(((ASTBoolVariable)jjtn000.jjtGetChild(0)).getVal());
      jjtn000.setRight(((ASTBoolVariable)jjtn000.jjtGetChild(1)).getVal());
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void BoolVariable(int type) throws ParseException {
 /*@bgen(jjtree) BoolVariable */
  ASTBoolVariable jjtn000 = new ASTBoolVariable(JJTBOOLVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
      case SUB:
      case LPAR:
      case SENSOR_FIRE:
      case SENSOR_LIGHT:
      case SENSOR_SHAKE:
      case SENSOR_PLANE:
      case SENSOR_GAS:
      case ID:
      case INT_NUM:
      case DOUBLE_NUM:
        Expression();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        jjtn000.setVal(((ASTExpression)jjtn000.jjtGetChild(0)).toSentence(this));
//        jjtThis.outputStatement();
        //sentences.add(jjtThis.toExprSentence());

        break;
      case CAR:
      case TEAM:
        ABCOperation(type);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        jjtn000.setVal(((ASTABCOperation)jjtn000.jjtGetChild(0)).toSentence(this));
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void Statement(int type) throws ParseException {
 /*@bgen(jjtree) Statement */
    ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);ASTABCOperation operation;
    try {
      try {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case DOUBLE:
        case CAR:
        case TEAM:
        case ID:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INT:
          case DOUBLE:
            Declaration();
                            jjtn000.setStatementType(ABC_Constant.DECLARATION);
            break;
          case ID:
            COperation();
                           jjtn000.setStatementType(ABC_Constant.COPERATION);
            break;
          case CAR:
          case TEAM:
            operation = ABCOperation(type);
                jjtn000.setStatementType(ABC_Constant.ABCOPERATION);
                jjtn000.setCommand(operation.toCommand());
            break;
          default:
            jj_la1[9] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(SEMI_COL);
          break;
        case IF:
          IfConditionStatement(type);
          break;
        case WHILE:
          WhileConditionStatement(type);
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (Exception e) {
        System.out.println("Exception: " + e.toString());
        sendErrorMsg(new ErrorType(2,e.getMessage()));
        Token t;
        do {
          t = getNextToken();
        } while (t.kind != SEMI_COL);
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

// for Declaration
  final public void Declaration() throws ParseException {
 /*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int type;
    try {
      type = Type();
      IdList(type);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public int Type() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      jj_consume_token(INT);
         {if (true) return ABC_Constant.INT;}
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
            {if (true) return ABC_Constant.DOUBLE;}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void IdList(int type) throws ParseException {
 /*@bgen(jjtree) IdList */
  ASTIdList jjtn000 = new ASTIdList(JJTIDLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(ID);
      if (funcMap.containsKey(t.toString()))
        {if (true) throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a function.");}
      for(Variable v:variables)
      {
        if(t.toString().equals(v.getName()) && v.getScope() <= scope)
          {if (true) throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a variable.");}
      }
      variables.add(new Variable(t.toString(), type, scope));
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        t = jj_consume_token(ID);
      if (funcMap.containsKey(t.toString()))
        {if (true) throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a function.");}
      for(Variable v:variables)
      {
        if(t.toString().equals(v.getName()) && v.getScope() <= scope)
          {if (true) throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a variable.");}
      }
      variables.add(new Variable(t.toString(), type, scope));
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// for COperation
  final public void COperation() throws ParseException {
 /*@bgen(jjtree) COperation */
  ASTCOperation jjtn000 = new ASTCOperation(JJTCOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  int oper;
    try {
      t = jj_consume_token(ID);
      oper = AssignOperator();
      Expression();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    ASTExpression expression = (ASTExpression) jjtn000.jjtGetChild(0);
    for (Variable variable : variables)
      if (variable.getName().equals(t.image)) {
        if (variable.getType() == ABC_Constant.INT) {
          int val;
          try {
            val = Integer.valueOf(variable.getVal());
          } catch (NumberFormatException e) {
            val = 0;
          }
          switch (oper) {
            case ABC_Constant.ASSIGN: val = Util.forceInt(this, expression.getVal()); break;
            case ABC_Constant.SELF_ADD: val += Util.forceInt(this, expression.getVal()); break;
            case ABC_Constant.SELF_SUB: val -= Util.forceInt(this, expression.getVal()); break;
            case ABC_Constant.SELF_MUL: val *= Util.forceInt(this, expression.getVal()); break;
            case ABC_Constant.SELF_DIV: val /= Util.forceInt(this, expression.getVal()); break;
          }
          variable.setVal(String.valueOf(val));
        } else if (variable.getType() == ABC_Constant.DOUBLE) {
          double val;
          try {
            val = Double.valueOf(variable.getVal());
          } catch (Exception e) {
            val = 0.0;
          }
          switch (oper) {
            case ABC_Constant.ASSIGN: val = Double.valueOf(expression.getVal()); break;
            case ABC_Constant.SELF_ADD: val += Double.valueOf(expression.getVal()); break;
            case ABC_Constant.SELF_SUB: val -= Double.valueOf(expression.getVal()); break;
            case ABC_Constant.SELF_MUL: val *= Double.valueOf(expression.getVal()); break;
            case ABC_Constant.SELF_DIV: val /= Double.valueOf(expression.getVal()); break;
          }
          variable.setVal(String.valueOf(val));
        } else {
          {if (true) throw new ParseException("Error: variable type '"+variable.getType()+"' isn't specified.");}
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public int AssignOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
            {if (true) return ABC_Constant.ASSIGN;}
      break;
    case SELF_ADD:
      jj_consume_token(SELF_ADD);
              {if (true) return ABC_Constant.SELF_ADD;}
      break;
    case SELF_SUB:
      jj_consume_token(SELF_SUB);
              {if (true) return ABC_Constant.SELF_SUB;}
      break;
    case SELF_MUL:
      jj_consume_token(SELF_MUL);
              {if (true) return ABC_Constant.SELF_MUL;}
      break;
    case SELF_DIV:
      jj_consume_token(SELF_DIV);
              {if (true) return ABC_Constant.SELF_DIV;}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// for ABCOperatin
  final public ASTABCOperation ABCOperation(int type) throws ParseException {
 /*@bgen(jjtree) ABCOperation */
  ASTABCOperation jjtn000 = new ASTABCOperation(JJTABCOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Object();
      jj_consume_token(DOT);
      Action();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setObject((ASTObject) jjtn000.jjtGetChild(0));
    jjtn000.setAction((ASTAction) jjtn000.jjtGetChild(1));
//    jjtThis.outputStatement();
    if (type == ABC_Constant.NORMAL_STMT) {
        if (jjtn000.getFunctionName() == ABC_Constant.FUNCTION)
              Util.addFuncSentence(this,
                jjtn000.getMyFuncName(), jjtn000.getObjectName(), jjtn000.getObjectID());
            else
              sentences.add(jjtn000.toSentence(this));
    }
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

// for Object
  final public void Object() throws ParseException {
 /*@bgen(jjtree) Object */
  ASTObject jjtn000 = new ASTObject(JJTOBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token idToken;
    try {
      ObjectName();
      jj_consume_token(LPAR);
      idToken = jj_consume_token(INT_NUM);
      jj_consume_token(RPAR);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    ASTObjectName child = (ASTObjectName) jjtn000.jjtGetChild(0);
    int val = child.getVal();
    jjtn000.setName(child.getVal());
    jjtn000.setObjectId(Integer.valueOf(idToken.image));
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void ObjectName() throws ParseException {
 /*@bgen(jjtree) ObjectName */
  ASTObjectName jjtn000 = new ASTObjectName(JJTOBJECTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CAR:
        jj_consume_token(CAR);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
               jjtn000.setVal(ABC_Constant.CAR);
        break;
      case TEAM:
        jj_consume_token(TEAM);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                jjtn000.setVal(ABC_Constant.TEAM);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

// for Action
  final public void Action() throws ParseException {
 /*@bgen(jjtree) Action */
  ASTAction jjtn000 = new ASTAction(JJTACTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ActionName();
      jj_consume_token(LPAR);
      ActionParams();
      jj_consume_token(RPAR);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    ASTActionName nameChild = (ASTActionName) jjtn000.jjtGetChild(0);
    jjtn000.setName(nameChild.getType());
    if (nameChild.getType() == ABC_Constant.FUNCTION)
      jjtn000.setFuncName(nameChild.getName());
    ASTActionParams paramChild = (ASTActionParams) jjtn000.jjtGetChild(1);
    jjtn000.setParamList(paramChild.getParamList());
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void ActionName() throws ParseException {
 /*@bgen(jjtree) ActionName */
  ASTActionName jjtn000 = new ASTActionName(JJTACTIONNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FORWARD:
        jj_consume_token(FORWARD);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                   jjtn000.setType(ABC_Constant.FORWARD);
        break;
      case BACK:
        jj_consume_token(BACK);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                jjtn000.setType(ABC_Constant.BACK);
        break;
      case ROTATE:
        jj_consume_token(ROTATE);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                  jjtn000.setType(ABC_Constant.ROTATE);
        break;
      case MOVE_TO:
        jj_consume_token(MOVE_TO);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                   jjtn000.setType(ABC_Constant.MOVE_TO);
        break;
      case BRAKE:
        jj_consume_token(BRAKE);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                 jjtn000.setType(ABC_Constant.BRAKE);
        break;
      case WAIT:
        jj_consume_token(WAIT);
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                jjtn000.setType(ABC_Constant.WAIT);
        break;
      case OBSTACLE:
        jj_consume_token(OBSTACLE);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                    jjtn000.setType(ABC_Constant.OBSTACLE);
        break;
      case X:
        jj_consume_token(X);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         jjtn000.setType(ABC_Constant.X);
        break;
      case Y:
        jj_consume_token(Y);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         jjtn000.setType(ABC_Constant.Y);
        break;
      case DIR:
        jj_consume_token(DIR);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
           jjtn000.setType(ABC_Constant.DIR);
        break;
      case SENSOR:
        jj_consume_token(SENSOR);
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
              jjtn000.setType(ABC_Constant.SENSOR);
        break;
      case REPORT:
        jj_consume_token(REPORT);
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
              jjtn000.setType(ABC_Constant.REPORT);
        break;
      case TEAM_ADD:
        jj_consume_token(TEAM_ADD);
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
              jjtn000.setType(ABC_Constant.TEAM_ADD);
        break;
      case TEAM_REMOVE:
        jj_consume_token(TEAM_REMOVE);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                 jjtn000.setType(ABC_Constant.TEAM_REMOVE);
        break;
      case ID:
        t = jj_consume_token(ID);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
             jjtn000.setType(ABC_Constant.FUNCTION); jjtn000.setName(t.image);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void ActionParams() throws ParseException {
 /*@bgen(jjtree) ActionParams */
  ASTActionParams jjtn000 = new ASTActionParams(JJTACTIONPARAMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
      case SUB:
      case LPAR:
      case SENSOR_FIRE:
      case SENSOR_LIGHT:
      case SENSOR_SHAKE:
      case SENSOR_PLANE:
      case SENSOR_GAS:
      case ID:
      case INT_NUM:
      case DOUBLE_NUM:
        Expression();
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[16] = jj_gen;
            break label_8;
          }
          jj_consume_token(COMMA);
          Expression();
        }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    for (int i = 0; i < jjtn000.jjtGetNumChildren(); i++) {
      ASTExpression child = (ASTExpression) jjtn000.jjtGetChild(i);
      jjtn000.addParam(child.getVal());
    }
        break;
      default:
        jj_la1[17] = jj_gen;
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;

      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// general
  final public void Expression() throws ParseException {
 /*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ASTTerm term;
  ASTExpression_p expression_p;
  ASTExpression_p_ne expression_p_ne;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAR:
      case ID:
      case INT_NUM:
      case DOUBLE_NUM:
        term = Term();
        expression_p = Expression_p(ABC_Constant.NONE,"",ABC_Constant.NONE,term.getVal(),term.getType());
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setVal(expression_p.getSynVal());
    jjtn000.setType(expression_p.getSynType());
//    System.out.println("normal");
//     System.out.println("expression "+jjtThis.getVal());
    // return jjtThis;

        break;
      case ADD:
      case SUB:
        expression_p_ne = Expression_p_ne(ABC_Constant.NONE,"",ABC_Constant.NONE,"",ABC_Constant.NONE);
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtn000.setVal(expression_p_ne.getSynVal());
        jjtn000.setType(expression_p_ne.getSynType());
//         System.out.println("expression "+jjtThis.getVal());
        // return jjtThis;

        break;
      case SENSOR_FIRE:
        jj_consume_token(SENSOR_FIRE);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                   jjtn000.setVal(ABC_Constant.SENSOR_FIRE); jjtn000.setType(ABC_Constant.INT);
        break;
      case SENSOR_LIGHT:
        jj_consume_token(SENSOR_LIGHT);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                    jjtn000.setVal(ABC_Constant.SENSOR_LIGHT); jjtn000.setType(ABC_Constant.INT);
        break;
      case SENSOR_SHAKE:
        jj_consume_token(SENSOR_SHAKE);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                    jjtn000.setVal(ABC_Constant.SENSOR_SHAKE); jjtn000.setType(ABC_Constant.INT);
        break;
      case SENSOR_PLANE:
        jj_consume_token(SENSOR_PLANE);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                    jjtn000.setVal(ABC_Constant.SENSOR_PLANE); jjtn000.setType(ABC_Constant.INT);
        break;
      case SENSOR_GAS:
        jj_consume_token(SENSOR_GAS);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                  jjtn000.setVal(ABC_Constant.SENSOR_GAS); jjtn000.setType(ABC_Constant.INT);
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public ASTExpression_p Expression_p(int oper,String termVal,int termType,
                            String broVal,int broType) throws ParseException {
 /*@bgen(jjtree) Expression_p */
  ASTExpression_p jjtn000 = new ASTExpression_p(JJTEXPRESSION_P);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int sonTermOper;
  ASTTerm sonTerm;
  ASTExpression_p sonExpression_p;
  if(oper==ABC_Constant.NONE){
    jjtn000.setInhType(broType);
    jjtn000.setInhVal(broVal);
  }else{
    if(oper==ABC_Constant.ADD){
      if(broType==ABC_Constant.INT&&termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(broVal)+Integer.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(broType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(broVal)+Double.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(broVal)+Integer.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(broVal)+Double.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
    }
    else if(oper==ABC_Constant.SUB){
      if(broType==ABC_Constant.INT&&termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(termVal)-Integer.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.DOUBLE && broType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(termVal)-Integer.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.INT && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(termVal)-Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.DOUBLE && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(termVal)-Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType==ABC_Constant.INT)
      {
          jjtn000.setInhType(ABC_Constant.INT);
          int res = -Integer.valueOf(broVal);
          jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res = -Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType == ABC_Constant.NONE)
      {
          jjtn000.setInhType(ABC_Constant.NONE);
          jjtn000.setInhVal("");
      }
    }
  }
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
      case SUB:
        sonTermOper = TermOp();
        sonTerm = Term();
        sonExpression_p = Expression_p(sonTermOper,jjtn000.getInhVal(),jjtn000.getInhType(),
            sonTerm.getVal(),sonTerm.getType());
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setSynVal(sonExpression_p.getSynVal());
    jjtn000.setSynType(sonExpression_p.getSynType());
    {if (true) return jjtn000;}
        break;
      default:
        jj_la1[19] = jj_gen;
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setSynVal(jjtn000.getInhVal());
    jjtn000.setSynType(jjtn000.getInhType());
    {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTExpression_p_ne Expression_p_ne(int oper,String termVal,int termType,
                            String broVal,int broType) throws ParseException {
 /*@bgen(jjtree) Expression_p_ne */
  ASTExpression_p_ne jjtn000 = new ASTExpression_p_ne(JJTEXPRESSION_P_NE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int sonTermOper;
  ASTTerm sonTerm;
  ASTExpression_p sonExpression_p;
  if(oper==ABC_Constant.NONE){
    jjtn000.setInhType(broType);
    jjtn000.setInhVal(broVal);
  }else{
    if(oper==ABC_Constant.ADD){
      if(broType==ABC_Constant.INT&&termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(broVal)+Integer.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(broType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(broVal)+Double.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(broVal)+Integer.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(broVal)+Double.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
    }
    else if(oper==ABC_Constant.SUB){
      if(broType==ABC_Constant.INT&&termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(termVal)-Integer.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.DOUBLE && broType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(termVal)-Integer.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.INT && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(termVal)-Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.DOUBLE && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(termVal)-Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType==ABC_Constant.INT)
      {
          jjtn000.setInhType(ABC_Constant.INT);
          int res = -Integer.valueOf(broVal);
          jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res = -Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType == ABC_Constant.NONE)
      {
          jjtn000.setInhType(ABC_Constant.NONE);
          jjtn000.setInhVal("");
      }
    }
  }
    try {
      sonTermOper = TermOp();
      sonTerm = Term();
      sonExpression_p = Expression_p(sonTermOper,jjtn000.getInhVal(),jjtn000.getInhType(),
          sonTerm.getVal(),sonTerm.getType());
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setSynVal(sonExpression_p.getSynVal());
    jjtn000.setSynType(sonExpression_p.getSynType());
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public int TermOp() throws ParseException {
 /*@bgen(jjtree) TermOp */
  ASTTermOp jjtn000 = new ASTTermOp(JJTTERMOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
        jj_consume_token(ADD);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
          jjtn000.setVal(ABC_Constant.ADD); {if (true) return jjtn000.getVal();}
        break;
      case SUB:
        jj_consume_token(SUB);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
          jjtn000.setVal(ABC_Constant.SUB); {if (true) return jjtn000.getVal();}
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTTerm Term() throws ParseException {
 /*@bgen(jjtree) Term */
  ASTTerm jjtn000 = new ASTTerm(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ASTFactor factor;
  ASTTerm_p child;
    try {
      factor = Factor();
      child = Term_p(ABC_Constant.NONE, "", ABC_Constant.NONE, factor.getVal(), factor.getType());
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setVal(child.getSynVal());
    jjtn000.setType(child.getSynType());
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTTerm_p Term_p(int oper, String faInh, int faType,
                      String factorVal, int factorType) throws ParseException {
 /*@bgen(jjtree) Term_p */
  ASTTerm_p jjtn000 = new ASTTerm_p(JJTTERM_P);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int sonOper;
  ASTFactor sonFactor;
  ASTTerm_p sonTerm_p;

   if(faType == ABC_Constant.NONE) {
    jjtn000.setInhType(factorType);
    jjtn000.setInhVal(factorVal);
   } else {
    if (oper == ABC_Constant.MUL)
    {
      if(factorType==ABC_Constant.INT&&faType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(factorVal)*Integer.valueOf(faInh);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(factorType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(factorVal)*Double.valueOf(faInh);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(faType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(factorVal)*Integer.valueOf(faInh);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(factorVal)*Double.valueOf(faInh);
        jjtn000.setInhVal(String.valueOf(res));
      }
    }
    if(oper == ABC_Constant.DIV)
    {
      if(factorType==ABC_Constant.INT&&faType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(faInh)/Integer.valueOf(factorVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(factorType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(faInh)/Integer.valueOf(factorVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(faType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(faInh)/Double.valueOf(factorVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(faInh)/Double.valueOf(factorVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
    }
   }
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MUL:
      case DIV:
        sonOper = FactorOp();
        sonFactor = Factor();
        sonTerm_p = Term_p(sonOper, jjtn000.getInhVal(), jjtn000.getInhType(),
                          sonFactor.getVal(), sonFactor.getType());
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setSynType(sonTerm_p.getSynType());
    jjtn000.setSynVal(sonTerm_p.getSynVal());
    {if (true) return jjtn000;}
        break;
      default:
        jj_la1[21] = jj_gen;
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
      int fft_inh_type=jjtn000.getInhType();
      String fft_inh_val=jjtn000.getInhVal();
      jjtn000.setSynType(fft_inh_type);
      jjtn000.setSynVal(fft_inh_val);
      {if (true) return jjtn000;}
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public int FactorOp() throws ParseException {
 /*@bgen(jjtree) FactorOp */
  ASTFactorOp jjtn000 = new ASTFactorOp(JJTFACTOROP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MUL:
        jj_consume_token(MUL);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
          jjtn000.setVal(ABC_Constant.MUL); {if (true) return ABC_Constant.MUL;}
        break;
      case DIV:
        jj_consume_token(DIV);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
          jjtn000.setVal(ABC_Constant.DIV); {if (true) return ABC_Constant.DIV;}
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTFactor Factor() throws ParseException {
 /*@bgen(jjtree) Factor */
  ASTFactor jjtn000 = new ASTFactor(JJTFACTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAR:
        jj_consume_token(LPAR);
        Expression();
        jj_consume_token(RPAR);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    ASTExpression fechild=(ASTExpression) jjtn000.jjtGetChild(0);
    String feval=fechild.getVal();
    int fetype=fechild.getType();
    jjtn000.setVal(feval);
    jjtn000.setType(fetype);
    {if (true) return jjtn000;}
        break;
      case ID:
      case INT_NUM:
      case DOUBLE_NUM:
        Value();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    ASTValue fvchild=(ASTValue) jjtn000.jjtGetChild(0);
    String fvval=fvchild.getVal();
    int fvtype=fvchild.getType();
    jjtn000.setVal(fvval);
    jjtn000.setType(fvtype);
    {if (true) return jjtn000;}
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Value() throws ParseException {
 /*@bgen(jjtree) Value */
  ASTValue jjtn000 = new ASTValue(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_NUM:
        IntLiteralValue();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    ASTIntLiteralValue vichild = (ASTIntLiteralValue) jjtn000.jjtGetChild(0);
    int vival = vichild.getVal();
    jjtn000.setType(ABC_Constant.INT);
    jjtn000.setVal(String.valueOf(vival));
        break;
      case DOUBLE_NUM:
        DoubleLiteralValue();
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     ASTDoubleLiteralValue vdchild = (ASTDoubleLiteralValue) jjtn000.jjtGetChild(0);
     double vdval=vdchild.getVal();
     jjtn000.setType(ABC_Constant.DOUBLE);
     jjtn000.setVal(String.valueOf(vdval));
        break;
      case ID:
        t = jj_consume_token(ID);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    boolean found = false;
    for (Variable variable : variables)
      if (variable.getName().equals((t.image))) {
        if(variable.getVal()==null)
        {
          String mes="Error: variable '"+t.toString()+"' isn't initialized.";
         {if (true) throw new ParseException(mes);}
        }
          jjtn000.setType(variable.getType());
          jjtn000.setVal(variable.getVal());
          found = true;
      }
    if (!found)
    {
      {if (true) throw new ParseException("Error: variable '"+t.toString()+"' isn't defined. ");}
    }
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void IntLiteralValue() throws ParseException {
 /*@bgen(jjtree) IntLiteralValue */
    ASTIntLiteralValue jjtn000 = new ASTIntLiteralValue(JJTINTLITERALVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(INT_NUM);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setVal(Integer.valueOf(t.image));
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void DoubleLiteralValue() throws ParseException {
 /*@bgen(jjtree) DoubleLiteralValue */
    ASTDoubleLiteralValue jjtn000 = new ASTDoubleLiteralValue(JJTDOUBLELITERALVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token td;
    try {
      td = jj_consume_token(DOUBLE_NUM);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.setVal(Double.valueOf(td.image));
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  /** Generated Token Manager. */
  public ABC_compilerTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[25];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x100,0x17800,0x17800,0x17000,0x0,0x17000,0x17000,0x7c000000,0xc00000,0x3000,0x17000,0x3000,0x0,0x3e0000,0x0,0x0,0x0,0xc00000,0xc00000,0xc00000,0xc00000,0x3000000,0x3000000,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x180,0x180,0x180,0x7ffe00,0x180,0x180,0x0,0xf8001a0,0x180,0x180,0x0,0x2,0x0,0x180,0x7ffe00,0x2,0xf800020,0xf800020,0x0,0x0,0x0,0x0,0x20,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x1,0x1,0x1,0x1,0x1,0x1,0x0,0x7,0x1,0x1,0x0,0x0,0x0,0x0,0x1,0x0,0x7,0x7,0x0,0x0,0x0,0x0,0x7,0x7,};
   }

  /** Constructor with InputStream. */
  public ABC_compiler(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public ABC_compiler(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ABC_compilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public ABC_compiler(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ABC_compilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public ABC_compiler(ABC_compilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ABC_compilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[68];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 25; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 68; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

        }
