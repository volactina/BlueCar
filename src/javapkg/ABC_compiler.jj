/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ABC_compiler.jj */
/*@egen*/options {
    STATIC = false;
                 
}
PARSER_BEGIN(ABC_compiler)
    package javapkg;
  import java.util.ArrayList;
  import java.util.HashMap;
  import java.io.*;
  import com.google.gson.Gson;
    import com.google.gson.GsonBuilder;

	public class ABC_compiler/*@bgen(jjtree)*/implements ABC_compilerTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTABC_compilerState jjtree = new JJTABC_compilerState();

/*@egen*/

    public HashMap<String, ArrayList<Command> > funcMap =
               new HashMap<String, ArrayList<Command> >();
        public ArrayList<Sentence> sentences=new ArrayList<Sentence>();
        public ArrayList<Variable> variables=new ArrayList<Variable>();
        public int scope = 0;
        public static ABC_compiler compiler;

        public static void main(String[] args)
        throws ParseException, TokenMgrError,
        NumberFormatException, FileNotFoundException, IOException {
                compiler = new ABC_compiler(
                                new FileInputStream("res/input.txt"));
                compiler.init();
                compiler.parse();
        }

        public void init() {
            funcMap.clear();
            sentences.clear();
            variables.clear();
            scope = 0;
        }
        public void parse() throws IOException {
    try{
            SimpleNode node = Procedure();
            sendTree(node);

            // node.dump("");

//                System.out.println("-----sentences-----");
//                System.out.println("size = " + sentences.size());
//                for (Sentence sentence : sentences) {
//                    System.out.println("[Sentence]");
//                    sentence.display();
//                }
//                System.out.println();
//                System.out.println("variables:");
//                for (Variable variable : variables)
//                  System.out.println(variable.getName() + " "
//                    + variable.getType() + " " + variable.getVal());
//                System.out.println();

          }catch(ParseException e)
          {
            sendErrorMsg(new ErrorType(2,e.getMessage()));
          }
        ErrorType err = Generator.generate_code(this, sentences);
        if (err.errortype == 2) {
            onGenFailure(err);
        }
        }

        public void onGenSuccess(ArrayList<String> code) throws IOException {
            System.out.println("Generate Success");
            System.out.println(code);
            sendTargetCode(code);
            Simulator.simulate(this, code);
        }

        public void onGenFailure(ErrorType err) throws IOException {
            System.out.println("Generate Failure");
            err.display();
            sendErrorMsg(err);
        }

        public void sendErrorMsg(ErrorType err) throws IOException {
            Message msg = new Message(err);
            WebSocket.sendMessage(this, new Gson().toJson(msg));
        }

        public void sendTargetCode(ArrayList<String> code) throws IOException {
          Message msg = new Message(code);
          WebSocket.sendMessage(this, new Gson().toJson(msg));
        }

        public void sendTree(SimpleNode tree) throws IOException {
                Message msg = new Message(tree);
		        Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
                WebSocket.sendMessage(this, gson.toJson(msg));
        }

        public void sendMsg(Operation oper) throws IOException {
            Message msg = new Message(oper);
            WebSocket.sendMessage(this, new Gson().toJson(msg));
        }

        public void finish() throws IOException {
            WebSocket.sendMessage(this, "finish");
        }
	}

PARSER_END(ABC_compiler)

SKIP: {
    " "
|	"\t"
|	"\r"
| "\n"
|	"\r\n"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN: {// key words
    <DEFINE: "#define">
|   <MAIN:"main">
|   <VOID:"void">
|	<FUNC:"function">
// type
| <INT:"int">
| <DOUBLE:"double">
// control
|	<IF:"if">
|	<ELSE:"else">
|	<WHILE:"while">
}

TOKEN: {// assignments
	<ASSIGN: "=">
| <SELF_ADD: "+=">
| <SELF_SUB: "-=">
| <SELF_MUL: "*=">
| <SELF_DIV: "/=">
}

// TOKEN: {// unary operators
//   <PLUS_ONE: "++">
// | <MINUS_ONE: "--">
// }

TOKEN: {// Arithmetic operators
	<ADD: "+">
|	<SUB: "-">

|	<MUL: "*">
|	<DIV: "/">
}

TOKEN: {// Relational operators
	<LT: "<">
|	<LE: "<=">
|	<MT: ">">
|	<ME: ">=">
|	<EQ: "==">
|	<NE: "!=">
}

TOKEN: {// Delimiters
	<SEMI_COL: ";">
|	<COMMA: ",">
|	<DOT: ".">
|	<LBRACE: "{">
|	<RBRACE: "}">
|	<LPAR: "(">
|	<RPAR: ")">
}

TOKEN: {// object
	<CAR: "Car">
|	<TEAM: "Team">
//|	<TASK: "Task">
}

TOKEN: {// action
	<FORWARD: "Forward">
|	<BACK: "Back">
|	<ROTATE: "Rotate">
|	<MOVE_TO: "MoveTo">
|	<BRAKE: "Brake">
|	<WAIT: "Wait">
|	<OBSTACLE: "Obstacle">
|	<X: "x">
|	<Y: "y">
|	<DIR: "dir">
|	<SENSOR: "Sensor">
|	<REPORT: "Report">
| <TEAM_ADD:"add">
| <TEAM_REMOVE:"remove">
}

TOKEN: {// action param
    <SENSOR_FIRE: "SENSOR_FIRE">
|   <SENSOR_LIGHT: "SENSOR_LIGHT">
|   <SENSOR_SHAKE: "SENSOR_SHAKE">
|   <SENSOR_PLANE: "SENSOR_PLANE">
|   <SENSOR_GAS: "SENSOR_GAS">
}

TOKEN: {<#LETTER: ["a"-"z", "A"-"Z"]>}
TOKEN: {<#DIGIT: ["0"-"9"]>}
TOKEN: {<#FRAC: "."(<DIGIT>)+>}
TOKEN: {<#CHARACTER: <LETTER>|<DIGIT>|"_">}
TOKEN: {<ID: (<LETTER> | "_") (<CHARACTER>)*>}
TOKEN: {<INT_NUM: (<DIGIT>)+>}
TOKEN: {<DOUBLE_NUM: (<DIGIT>)+ <FRAC>>}
TOKEN: {<ERROR:~[]>}


SimpleNode Procedure()     :{/*@bgen(jjtree) Root */
  ASTRoot jjtn000 = new ASTRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Root */
    try {
/*@egen*/
    ( Define() )*
  ( Statement(ABC_Constant.NORMAL_STMT) | FunctionDef())*
  MainFunction()
  <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Define():
{/*@bgen(jjtree) Define */
    ASTDefine jjtn000 = new ASTDefine(JJTDEFINE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Define */
    try {
/*@egen*/
    <DEFINE> t = <ID> IntLiteralValue()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        Variable newVar = new Variable(t.image, ABC_Constant.INT, scope);
        if(variables.size()!=0)
        {
          if (funcMap.containsKey(t.toString()))
            throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a function.");
          for(Variable v:variables)
          {
            if(t.image.equals(v.getName()) && v.getScope() <= scope)
              throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a variable.");
          }
        }
        ASTIntLiteralValue child = (ASTIntLiteralValue)jjtn000.jjtGetChild(0);
        newVar.setVal(String.valueOf(child.getVal()));
        variables.add(newVar);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void MainFunction():{/*@bgen(jjtree) MainFunction */
  ASTMainFunction jjtn000 = new ASTMainFunction(JJTMAINFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MainFunction */
  try {
/*@egen*/
  <VOID> <MAIN> <LPAR> <RPAR>
  Block()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Block():
{/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  scope++;
}
{/*@bgen(jjtree) Block */
  try {
/*@egen*/
  <LBRACE>
  (
    Statement(ABC_Constant.NORMAL_STMT)
  )*
  <RBRACE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { Util.closeScope(this); scope--; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void FunctionDef():
{/*@bgen(jjtree) FunctionDef */
  ASTFunctionDef jjtn000 = new ASTFunctionDef(JJTFUNCTIONDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  String funcName = "";
}
{/*@bgen(jjtree) FunctionDef */
    try {
/*@egen*/
    try{
  <FUNC> funcName = <ID>.image <LPAR><RPAR>
  <LBRACE> { scope++; }
  ( Action() <SEMI_COL>)*
  <RBRACE>
  }catch (Exception e) {
      System.out.println(e.toString());
      sendErrorMsg(new ErrorType(2,e.getMessage()));
      // Token t;
      // do {
      //   t = getNextToken();
      // } while (t.kind != RBRACE);
    }/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    try {
    boolean funcHasDefinedByVal=false;
    for(Variable v:variables)
    {
      if(funcName.equals(v.getName()) && v.getScope() <= scope)
        funcHasDefinedByVal=true;
    }
    if (funcMap.containsKey(funcName))
      throw new ParseException("Error: function '"+funcName+"' the name has been used for a function.");
    else if (funcHasDefinedByVal)
      throw new ParseException("Error: function '"+funcName+"' the name has been used for a variable.");
    else{
      ArrayList<Command> funcCommands = new ArrayList<Command>();
      for (int i = 0; i < jjtn000.jjtGetNumChildren(); i++) {
        ASTAction action = (ASTAction) jjtn000.jjtGetChild(i);
        funcCommands.add(
          new Command(0, 0, action.getName(),
            action.getFuncName(), action.getParamList()));
      }
      funcMap.put(funcName, funcCommands);
    }
    Util.closeScope(this);
     scope--;
     }catch (Exception e) {
           System.out.println(e.toString());
           sendErrorMsg(new ErrorType(2,e.getMessage()));
           // Token t;
           // do {
           //   t = getNextToken();
           // } while (t.kind != RBRACE);
         }
  }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IfConditionStatement(int type):
{/*@bgen(jjtree) IfConditionStatement */
    ASTIfConditionStatement jjtn000 = new ASTIfConditionStatement(JJTIFCONDITIONSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Sentence execStmt;
}
{/*@bgen(jjtree) IfConditionStatement */
    try {
/*@egen*/
    <IF><LPAR>Condition(ABC_Constant.IF_STMT)<RPAR>
    <LBRACE> {scope++;}
    (
        Statement(ABC_Constant.IF_STMT)
    )*
    <RBRACE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setCondition((ASTCondition)jjtn000.jjtGetChild(0));
        for (int i = 1; i < jjtn000.jjtGetNumChildren(); i++) {
            ASTStatement child = (ASTStatement) jjtn000.jjtGetChild(i);
            System.out.println("stmt: " + new Gson().toJson(child.getCommand()));
            if (child.getCommand().getFunctionName() == ABC_Constant.FUNCTION)
                  Util.addExecStmt(this, jjtn000,
                    child.getCommand().getMyFuncName(),
                    child.getCommand().getObjectName(),
                    child.getCommand().getObjectID());
                else
                  jjtn000.addExecStmt(this, child);
        }
//        jjtThis.toSentence().display();
//        jjtThis.outputIfStatement();
        sentences.add(jjtn000.toSentence());
        Util.closeScope(this);
        scope--;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void WhileConditionStatement(int type):
{/*@bgen(jjtree) WhileConditionStatement */
    ASTWhileConditionStatement jjtn000 = new ASTWhileConditionStatement(JJTWHILECONDITIONSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Sentence execStmt;
}
{/*@bgen(jjtree) WhileConditionStatement */
    try {
/*@egen*/
    <WHILE><LPAR>Condition(ABC_Constant.WHILE_STMT)<RPAR>
    <LBRACE> {scope++;}
    (
        Statement(ABC_Constant.WHILE_STMT)
    )*
    <RBRACE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setCondition((ASTCondition)jjtn000.jjtGetChild(0));
        for (int i = 1; i < jjtn000.jjtGetNumChildren(); i++) {
            ASTStatement child = (ASTStatement) jjtn000.jjtGetChild(i);
            if (child.getCommand().getFunctionName() == ABC_Constant.FUNCTION)
                  Util.addExecStmt(this, jjtn000,
                    child.getCommand().getMyFuncName(),
                    child.getCommand().getObjectName(),
                    child.getCommand().getObjectID());
                else
                  jjtn000.addExecStmt(this, child);
        }
//        jjtThis.outputWhileStatement();
        sentences.add(jjtn000.toSentence());
        Util.closeScope(this);
        scope--;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Condition(int type):
{/*@bgen(jjtree) Condition */
  ASTCondition jjtn000 = new ASTCondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Condition */
    try {
/*@egen*/
    BoolVariable(type)
    (  <LT>{jjtn000.setOperator(ABC_Constant.LESS_THAN);}
     | <LE>{jjtn000.setOperator(ABC_Constant.LESS_EQUAL);}
     | <MT>{jjtn000.setOperator(ABC_Constant.MORE_THAN);}
     | <ME>{jjtn000.setOperator(ABC_Constant.MORE_EQUAL);}
     | <EQ>{jjtn000.setOperator(ABC_Constant.EQUAL);}
     )
    BoolVariable(type)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.setLeft(((ASTBoolVariable)jjtn000.jjtGetChild(0)).getVal());
      jjtn000.setRight(((ASTBoolVariable)jjtn000.jjtGetChild(1)).getVal());
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BoolVariable(int type):
{/*@bgen(jjtree) BoolVariable */
  ASTBoolVariable jjtn000 = new ASTBoolVariable(JJTBOOLVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BoolVariable */
    try {
/*@egen*/
    Expression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setVal(((ASTExpression)jjtn000.jjtGetChild(0)).toSentence(this));
//        jjtThis.outputStatement();
        //sentences.add(jjtThis.toExprSentence());
    }
|   ABCOperation(type)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setVal(((ASTABCOperation)jjtn000.jjtGetChild(0)).toSentence(this));
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Statement(int type):
{/*@bgen(jjtree) Statement */
    ASTStatement jjtn000 = new ASTStatement(JJTSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    ASTABCOperation operation;
}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    try{
    (
        (
             Declaration() {jjtn000.setStatementType(ABC_Constant.DECLARATION);}
         |   COperation() {jjtn000.setStatementType(ABC_Constant.COPERATION);}
         |   operation = ABCOperation(type)
            {
                jjtn000.setStatementType(ABC_Constant.ABCOPERATION);
                jjtn000.setCommand(operation.toCommand());
            }
        )
        <SEMI_COL>
    )
    |   IfConditionStatement(type)
    |   WhileConditionStatement(type)
    }catch (Exception e) {
        System.out.println("Exception: " + e.toString());
        sendErrorMsg(new ErrorType(2,e.getMessage()));
        Token t;
        do {
          t = getNextToken();
        } while (t.kind != SEMI_COL);
  }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

// for Declaration
void Declaration():
{/*@bgen(jjtree) Declaration */
  ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  int type;
}
{/*@bgen(jjtree) Declaration */
  try {
/*@egen*/
  type = Type()
  IdList(type)/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

int Type()     :
{}
{
  <INT> {return ABC_Constant.INT;}
| <DOUBLE> {return ABC_Constant.DOUBLE;}

}

void IdList(int type):
{/*@bgen(jjtree) IdList */
  ASTIdList jjtn000 = new ASTIdList(JJTIDLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) IdList */
  try {
/*@egen*/
  t = <ID>
  {
      if (funcMap.containsKey(t.toString()))
        throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a function.");
      for(Variable v:variables)
      {
        if(t.toString().equals(v.getName()) && v.getScope() <= scope)
          throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a variable.");
      }
      variables.add(new Variable(t.toString(), type, scope));
  }
  (
    <COMMA> t = <ID>
    {
      if (funcMap.containsKey(t.toString()))
        throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a function.");
      for(Variable v:variables)
      {
        if(t.toString().equals(v.getName()) && v.getScope() <= scope)
          throw new ParseException("Error: variable '"+t.toString()+"' the name has been used for a variable.");
      }
      variables.add(new Variable(t.toString(), type, scope));
    }
  )*/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// for COperation
void COperation():
{/*@bgen(jjtree) COperation */
  ASTCOperation jjtn000 = new ASTCOperation(JJTCOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  int oper;
}
{/*@bgen(jjtree) COperation */
  try {
/*@egen*/
  t = <ID>
  oper = AssignOperator()
  Expression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    ASTExpression expression = (ASTExpression) jjtn000.jjtGetChild(0);
    for (Variable variable : variables)
      if (variable.getName().equals(t.image)) {
        if (variable.getType() == ABC_Constant.INT) {
          int val;
          try {
            val = Integer.valueOf(variable.getVal());
          } catch (NumberFormatException e) {
            val = 0;
          }
          switch (oper) {
            case ABC_Constant.ASSIGN: val = Util.forceInt(this, expression.getVal()); break;
            case ABC_Constant.SELF_ADD: val += Util.forceInt(this, expression.getVal()); break;
            case ABC_Constant.SELF_SUB: val -= Util.forceInt(this, expression.getVal()); break;
            case ABC_Constant.SELF_MUL: val *= Util.forceInt(this, expression.getVal()); break;
            case ABC_Constant.SELF_DIV: val /= Util.forceInt(this, expression.getVal()); break;
          }
          variable.setVal(String.valueOf(val));
        } else if (variable.getType() == ABC_Constant.DOUBLE) {
          double val;
          try {
            val = Double.valueOf(variable.getVal());
          } catch (Exception e) {
            val = 0.0;
          }
          switch (oper) {
            case ABC_Constant.ASSIGN: val = Double.valueOf(expression.getVal()); break;
            case ABC_Constant.SELF_ADD: val += Double.valueOf(expression.getVal()); break;
            case ABC_Constant.SELF_SUB: val -= Double.valueOf(expression.getVal()); break;
            case ABC_Constant.SELF_MUL: val *= Double.valueOf(expression.getVal()); break;
            case ABC_Constant.SELF_DIV: val /= Double.valueOf(expression.getVal()); break;
          }
          variable.setVal(String.valueOf(val));
        } else {
          throw new ParseException("Error: variable type '"+variable.getType()+"' isn't specified.");
        }
      }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

int AssignOperator()     :
{}
{
  <ASSIGN> {return ABC_Constant.ASSIGN;}
| <SELF_ADD> {return ABC_Constant.SELF_ADD;}
| <SELF_SUB> {return ABC_Constant.SELF_SUB;}
| <SELF_MUL> {return ABC_Constant.SELF_MUL;}
| <SELF_DIV> {return ABC_Constant.SELF_DIV;}
}

// for ABCOperatin
ASTABCOperation ABCOperation(int type):
{/*@bgen(jjtree) ABCOperation */
  ASTABCOperation jjtn000 = new ASTABCOperation(JJTABCOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ABCOperation */
  try {
/*@egen*/
  Object()
  <DOT>
  Action()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { 
    jjtn000.setObject((ASTObject) jjtn000.jjtGetChild(0)); 
    jjtn000.setAction((ASTAction) jjtn000.jjtGetChild(1));
//    jjtThis.outputStatement();
    if (type == ABC_Constant.NORMAL_STMT) {
        if (jjtn000.getFunctionName() == ABC_Constant.FUNCTION)
              Util.addFuncSentence(this,
                jjtn000.getMyFuncName(), jjtn000.getObjectName(), jjtn000.getObjectID());
            else
              sentences.add(jjtn000.toSentence(this));
    }
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// for Object
void Object():
{/*@bgen(jjtree) Object */
  ASTObject jjtn000 = new ASTObject(JJTOBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token idToken;
}
{/*@bgen(jjtree) Object */
        try {
/*@egen*/
	ObjectName() <LPAR> idToken = <INT_NUM> <RPAR>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    ASTObjectName child = (ASTObjectName) jjtn000.jjtGetChild(0);
    int val = child.getVal();
    jjtn000.setName(child.getVal());
    jjtn000.setObjectId(Integer.valueOf(idToken.image));
  }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ObjectName():
{/*@bgen(jjtree) ObjectName */
  ASTObjectName jjtn000 = new ASTObjectName(JJTOBJECTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectName */
        try {
/*@egen*/
	<CAR>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {jjtn000.setVal(ABC_Constant.CAR);}
|	<TEAM>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.setVal(ABC_Constant.TEAM);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
//|	<TASK> {jjtThis.setVal(ABC_Constant.TASK);}
}

// for Action
void Action():
{/*@bgen(jjtree) Action */
  ASTAction jjtn000 = new ASTAction(JJTACTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Action */
        try {
/*@egen*/
	ActionName() <LPAR> ActionParams() <RPAR>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    ASTActionName nameChild = (ASTActionName) jjtn000.jjtGetChild(0);
    jjtn000.setName(nameChild.getType());
    if (nameChild.getType() == ABC_Constant.FUNCTION)
      jjtn000.setFuncName(nameChild.getName());
    ASTActionParams paramChild = (ASTActionParams) jjtn000.jjtGetChild(1);
    jjtn000.setParamList(paramChild.getParamList());
  }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ActionName():
{/*@bgen(jjtree) ActionName */
  ASTActionName jjtn000 = new ASTActionName(JJTACTIONNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ActionName */
        try {
/*@egen*/
	<FORWARD>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setType(ABC_Constant.FORWARD);}
|	<BACK>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.setType(ABC_Constant.BACK);}
|	<ROTATE>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.setType(ABC_Constant.ROTATE);}
|	<MOVE_TO>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setType(ABC_Constant.MOVE_TO);}
|	<BRAKE>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.setType(ABC_Constant.BRAKE);}
|	<WAIT>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.setType(ABC_Constant.WAIT);}
|	<OBSTACLE>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setType(ABC_Constant.OBSTACLE);}
|   <X>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ {jjtn000.setType(ABC_Constant.X);}
|   <Y>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ {jjtn000.setType(ABC_Constant.Y);}
|   <DIR>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {jjtn000.setType(ABC_Constant.DIR);}
|   <SENSOR>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.setType(ABC_Constant.SENSOR);}
|   <REPORT>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.setType(ABC_Constant.REPORT);}
| <TEAM_ADD>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.setType(ABC_Constant.TEAM_ADD);}
| <TEAM_REMOVE>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.setType(ABC_Constant.TEAM_REMOVE);}
| t = <ID>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/  {jjtn000.setType(ABC_Constant.FUNCTION); jjtn000.setName(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

void ActionParams():
{/*@bgen(jjtree) ActionParams */
  ASTActionParams jjtn000 = new ASTActionParams(JJTACTIONPARAMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ActionParams */
  try {
/*@egen*/
  (
    Expression() (<COMMA> Expression())*
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    for (int i = 0; i < jjtn000.jjtGetNumChildren(); i++) {
      ASTExpression child = (ASTExpression) jjtn000.jjtGetChild(i);
      jjtn000.addParam(child.getVal());
    }
  }
  |/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// general
void Expression():
{/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  ASTTerm term;
  ASTExpression_p expression_p;
  ASTExpression_p_ne expression_p_ne;
}
{/*@bgen(jjtree) Expression */
  try {
/*@egen*/
  term=Term() 
  expression_p=Expression_p(ABC_Constant.NONE,"",ABC_Constant.NONE,term.getVal(),term.getType())/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setVal(expression_p.getSynVal());
    jjtn000.setType(expression_p.getSynType());
//    System.out.println("normal");
//     System.out.println("expression "+jjtThis.getVal());
    // return jjtThis;
  }
  | expression_p_ne=Expression_p_ne(ABC_Constant.NONE,"",ABC_Constant.NONE,"",ABC_Constant.NONE)/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
      }
/*@egen*/
      {
        jjtn000.setVal(expression_p_ne.getSynVal());
        jjtn000.setType(expression_p_ne.getSynType());
//         System.out.println("expression "+jjtThis.getVal());
        // return jjtThis;
      }
  | <SENSOR_FIRE>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.setVal(ABC_Constant.SENSOR_FIRE); jjtn000.setType(ABC_Constant.INT);}
  | <SENSOR_LIGHT>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setVal(ABC_Constant.SENSOR_LIGHT); jjtn000.setType(ABC_Constant.INT);}
  | <SENSOR_SHAKE>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setVal(ABC_Constant.SENSOR_SHAKE); jjtn000.setType(ABC_Constant.INT);}
  | <SENSOR_PLANE>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setVal(ABC_Constant.SENSOR_PLANE); jjtn000.setType(ABC_Constant.INT);}
  | <SENSOR_GAS>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.setVal(ABC_Constant.SENSOR_GAS); jjtn000.setType(ABC_Constant.INT);}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTExpression_p Expression_p(int oper,String termVal,int termType,
                            String broVal,int broType):
{/*@bgen(jjtree) Expression_p */
  ASTExpression_p jjtn000 = new ASTExpression_p(JJTEXPRESSION_P);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  int sonTermOper;
  ASTTerm sonTerm;
  ASTExpression_p sonExpression_p;
  if(oper==ABC_Constant.NONE){
    jjtn000.setInhType(broType);
    jjtn000.setInhVal(broVal);
  }else{
    if(oper==ABC_Constant.ADD){
      if(broType==ABC_Constant.INT&&termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(broVal)+Integer.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(broType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(broVal)+Double.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(broVal)+Integer.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(broVal)+Double.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
    }
    else if(oper==ABC_Constant.SUB){
      if(broType==ABC_Constant.INT&&termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(termVal)-Integer.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.DOUBLE && broType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(termVal)-Integer.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.INT && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(termVal)-Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.DOUBLE && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(termVal)-Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType==ABC_Constant.INT)
      {
          jjtn000.setInhType(ABC_Constant.INT);
          int res = -Integer.valueOf(broVal);
          jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res = -Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType == ABC_Constant.NONE)
      {
          jjtn000.setInhType(ABC_Constant.NONE);
          jjtn000.setInhVal("");
      }
    }
  }
}
{/*@bgen(jjtree) Expression_p */
  try {
/*@egen*/
  sonTermOper=TermOp() 
  sonTerm=Term() 
  sonExpression_p=Expression_p(sonTermOper,jjtn000.getInhVal(),jjtn000.getInhType(),
    sonTerm.getVal(),sonTerm.getType())/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setSynVal(sonExpression_p.getSynVal());
    jjtn000.setSynType(sonExpression_p.getSynType());
    return jjtn000;
  }
   |/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  {
    jjtn000.setSynVal(jjtn000.getInhVal());
    jjtn000.setSynType(jjtn000.getInhType());
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
 }

ASTExpression_p_ne Expression_p_ne(int oper,String termVal,int termType,
                            String broVal,int broType):
{/*@bgen(jjtree) Expression_p_ne */
  ASTExpression_p_ne jjtn000 = new ASTExpression_p_ne(JJTEXPRESSION_P_NE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  int sonTermOper;
  ASTTerm sonTerm;
  ASTExpression_p sonExpression_p;
  if(oper==ABC_Constant.NONE){
    jjtn000.setInhType(broType);
    jjtn000.setInhVal(broVal);
  }else{
    if(oper==ABC_Constant.ADD){
      if(broType==ABC_Constant.INT&&termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(broVal)+Integer.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(broType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(broVal)+Double.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(broVal)+Integer.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(broVal)+Double.valueOf(termVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
    }
    else if(oper==ABC_Constant.SUB){
      if(broType==ABC_Constant.INT&&termType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(termVal)-Integer.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.DOUBLE && broType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(termVal)-Integer.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.INT && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(termVal)-Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(termType==ABC_Constant.DOUBLE && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(termVal)-Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType==ABC_Constant.INT)
      {
          jjtn000.setInhType(ABC_Constant.INT);
          int res = -Integer.valueOf(broVal);
          jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType==ABC_Constant.DOUBLE)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res = -Double.valueOf(broVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if (termType==ABC_Constant.NONE && broType == ABC_Constant.NONE)
      {
          jjtn000.setInhType(ABC_Constant.NONE);
          jjtn000.setInhVal("");
      }
    }
  }
}
{/*@bgen(jjtree) Expression_p_ne */
  try {
/*@egen*/
  sonTermOper=TermOp()
  sonTerm=Term()
  sonExpression_p=Expression_p(sonTermOper,jjtn000.getInhVal(),jjtn000.getInhType(),
    sonTerm.getVal(),sonTerm.getType())/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setSynVal(sonExpression_p.getSynVal());
    jjtn000.setSynType(sonExpression_p.getSynType());
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
 }


int TermOp():
{/*@bgen(jjtree) TermOp */
  ASTTermOp jjtn000 = new ASTTermOp(JJTTERMOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TermOp */
    try {
/*@egen*/
    <ADD>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/{jjtn000.setVal(ABC_Constant.ADD); return jjtn000.getVal();}
|   <SUB>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/{jjtn000.setVal(ABC_Constant.SUB); return jjtn000.getVal();}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ASTTerm Term():
{/*@bgen(jjtree) Term */
  ASTTerm jjtn000 = new ASTTerm(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  ASTFactor factor;
  ASTTerm_p child;
}
{/*@bgen(jjtree) Term */
  try {
/*@egen*/
  factor = Factor()
  child = Term_p(ABC_Constant.NONE, "", ABC_Constant.NONE, factor.getVal(), factor.getType())/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setVal(child.getSynVal());
    jjtn000.setType(child.getSynType());
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTTerm_p Term_p(int oper, String faInh, int faType,
                      String factorVal, int factorType):
{/*@bgen(jjtree) Term_p */
  ASTTerm_p jjtn000 = new ASTTerm_p(JJTTERM_P);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  int sonOper;
  ASTFactor sonFactor;
  ASTTerm_p sonTerm_p;

   if(faType == ABC_Constant.NONE) {
    jjtn000.setInhType(factorType);
    jjtn000.setInhVal(factorVal);
   } else {
    if (oper == ABC_Constant.MUL)
    {
      if(factorType==ABC_Constant.INT&&faType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(factorVal)*Integer.valueOf(faInh);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(factorType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(factorVal)*Double.valueOf(faInh);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(faType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(factorVal)*Integer.valueOf(faInh);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(factorVal)*Double.valueOf(faInh);
        jjtn000.setInhVal(String.valueOf(res));
      }
    }
    if(oper == ABC_Constant.DIV)
    {
      if(factorType==ABC_Constant.INT&&faType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.INT);
        int res=Integer.valueOf(faInh)/Integer.valueOf(factorVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(factorType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(faInh)/Integer.valueOf(factorVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else if(faType==ABC_Constant.INT)
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Integer.valueOf(faInh)/Double.valueOf(factorVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
      else
      {
        jjtn000.setInhType(ABC_Constant.DOUBLE);
        double res=Double.valueOf(faInh)/Double.valueOf(factorVal);
        jjtn000.setInhVal(String.valueOf(res));
      }
    }
   } 
}

{/*@bgen(jjtree) Term_p */
  try {
/*@egen*/
  sonOper = FactorOp()
  sonFactor = Factor()
  sonTerm_p = Term_p(sonOper, jjtn000.getInhVal(), jjtn000.getInhType(), 
                  sonFactor.getVal(), sonFactor.getType())/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setSynType(sonTerm_p.getSynType());
    jjtn000.setSynVal(sonTerm_p.getSynVal());
    return jjtn000;
  }
|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ {
      int fft_inh_type=jjtn000.getInhType();
      String fft_inh_val=jjtn000.getInhVal();
      jjtn000.setSynType(fft_inh_type);
      jjtn000.setSynVal(fft_inh_val);
      return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

int FactorOp():
{/*@bgen(jjtree) FactorOp */
  ASTFactorOp jjtn000 = new ASTFactorOp(JJTFACTOROP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FactorOp */
    try {
/*@egen*/
    <MUL>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/{jjtn000.setVal(ABC_Constant.MUL); return ABC_Constant.MUL;}
|   <DIV>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/{jjtn000.setVal(ABC_Constant.DIV); return ABC_Constant.DIV;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ASTFactor Factor():
{/*@bgen(jjtree) Factor */
  ASTFactor jjtn000 = new ASTFactor(JJTFACTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Factor */
  try {
/*@egen*/
  <LPAR> Expression() <RPAR>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    ASTExpression fechild=(ASTExpression) jjtn000.jjtGetChild(0);
    String feval=fechild.getVal();
    int fetype=fechild.getType();
    jjtn000.setVal(feval);
    jjtn000.setType(fetype);
    return jjtn000;
  }
| Value()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    ASTValue fvchild=(ASTValue) jjtn000.jjtGetChild(0);
    String fvval=fvchild.getVal();
    int fvtype=fvchild.getType();
    jjtn000.setVal(fvval);
    jjtn000.setType(fvtype);
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Value():
{/*@bgen(jjtree) Value */
  ASTValue jjtn000 = new ASTValue(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Value */
  try {
/*@egen*/
  IntLiteralValue()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    ASTIntLiteralValue vichild = (ASTIntLiteralValue) jjtn000.jjtGetChild(0);
    int vival = vichild.getVal();
    jjtn000.setType(ABC_Constant.INT);
    jjtn000.setVal(String.valueOf(vival));
  }
| DoubleLiteralValue()/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   {
     ASTDoubleLiteralValue vdchild = (ASTDoubleLiteralValue) jjtn000.jjtGetChild(0);
     double vdval=vdchild.getVal();
     jjtn000.setType(ABC_Constant.DOUBLE);
     jjtn000.setVal(String.valueOf(vdval));
   }
| t = <ID>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    boolean found = false;
    for (Variable variable : variables) 
      if (variable.getName().equals((t.image))) {
        if(variable.getVal()==null)
        {
          String mes="Error: variable '"+t.toString()+"' isn't initialized.";
         throw new ParseException(mes); 
        }
          jjtn000.setType(variable.getType());
          jjtn000.setVal(variable.getVal());
          found = true;
      }
    if (!found)
    {
      throw new ParseException("Error: variable '"+t.toString()+"' isn't defined. ");
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void IntLiteralValue():
{/*@bgen(jjtree) IntLiteralValue */
    ASTIntLiteralValue jjtn000 = new ASTIntLiteralValue(JJTINTLITERALVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) IntLiteralValue */
  try {
/*@egen*/
  t = <INT_NUM>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.setVal(Integer.valueOf(t.image)); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DoubleLiteralValue():
{/*@bgen(jjtree) DoubleLiteralValue */
    ASTDoubleLiteralValue jjtn000 = new ASTDoubleLiteralValue(JJTDOUBLELITERALVALUE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token td;
}
{/*@bgen(jjtree) DoubleLiteralValue */
  try {
/*@egen*/
  td=<DOUBLE_NUM>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.setVal(Double.valueOf(td.image));}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}




